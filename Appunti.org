#+PROPERTY: header-args:coq :session *coq*
* Disclaimer

Questi appunti seguono il primo volume di  *Software Foundations* scritto a vari mani che può essere letto nella sua interezza qui: [[https://softwarefoundations.cis.upenn.edu/][Software Foundations]]. Gli appunti sono un riassunto  di alcuni degli argomenti trattati durante il corso di *Metodi Formali* tenuto dal prof. Momigliano dell'Università degli Studi di Milano.

Disclaimer: Sono sicuro al 100% di commettere errori, è la prima volta che mi approccio all'argomento e non ho il tempo per rileggere quello che ho scritto, questi appunti sono rilasciati sotto licenza MIT senza violare il copyright degli scrittori originali.

* Introduzione a rocq

Rocq (conosciuto precedentemente come coq) è un _proof-assistant_, ovvero uno strumento utilizzato per formalizzare concetti matematici, dimostrare teoremi e verificare la correttezza di algoritmi e programmi.

Un *proof-assistant* permette di sviluppare dimostrazioni matematiche in garantendo maggiore affidabilità rispetto alle verifiche manuali.

Rocq usa come linguaggio formale "*Gallina*" per scrivere definizioni, algoritmi eseguibili e teoremi. È utilizzato nell'informatica teorica per la formalizzazione del software, per assicurare che un programma si comporti esattamente secondo le sue specifiche. È inoltre possibile generare automaticamente codice OCaml o Haskell a partire dalle specifiche verificate.

Il linguaggio di programmazione di Rocq, Gallina, è un linguaggio funzionale. Lo stile funzionale in programmazione ha fondamenti matematici, se una procedura non ha _effetti collaterali_ allora tutto quello che ci interessa è che associ un *input* ad un *output*. I linguaggi funzionali trattano le funzioni come "*first-class values*" ovvero sono esse stesse valori che possono essere passati ad altre funzioni, ogni funzione può essere trattata come *data*.

* Fondamenti
** Tipi enumerati

Una delle caratteristiche di Rocq è che include un numero estremamente limitato di feature built-in. Per esempio invece dei soli ti tipi atomici (booleani, interi, stringhe, ...) invece usa un meccanismo per definire nuovi tipi. Nonostante questo esistono molte librerie che "fanno il lavoro sporco" per noi introducendo tipi comuni utili per le nostre dimostrazioni come la libreria standard *Stdlib*.

Vediamo un esempio del meccanismo di definizione dei tipi.

#+begin_src coq :session *coq*
  Inductive day : Type :=
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday
  | sunday.
#+end_src

Possiamo quindi scrivere funzioni che usano il tipo che abbiamo appena creato. Utilizzando il pattern matching con ~match~ .. ~with~ ... ~end~

#+begin_src coq :session *coq*
  Definition next_working_day (d:day) : day :=
    match d with
    | monday => tuesday
    | tuesday => wednesday
    | wednesday => thursday
    | thursday => friday
    | friday => monday
    | saturday => monday
    | sunday => monday
    end.
#+end_src

Foreshadowing che mi pareva giusto inserire qui, è possibile fare matching di più valori allo stesso tempo per non riscrivere la stessa cosa più volte.

#+begin_src coq :session *coq*
  Definition month_to_season (m : month) : season :=
    match m with
    | March | April | May => Spring
    | June | July | August => Summer
    | September| October | November => Autumn
    | December | January | February => Winter 
    end.
#+end_src
  
Notare che gli argomenti e i valori ritornati sono dichiarati esplicitamente nella prima riga, come molti linguaggi Rocq può fare inferenza di tipo da solo se non sono esplicitati, ma è buona pratica includerli sempre.

Possiamo valutare una funzione con il comando ~Compute~

#+begin_src coq :session *coq*
  Compute (next_working_day friday).
  (* ==> monday : day *)
  Compute (next_working_day (next_working_day saturday)).
  (* ==> tuesday : day *)
#+end_src

Tramite il comando ~Example~ possiamo invece testare qual è il risultato che ci aspettiamo da una funzione.

#+begin_src coq :session *coq*
  Example test_next_working_day:
    (next_working_day (next_working_day saturday)) = tuesday.
#+end_src

~Example~ crea un'*asserzione* e gli da un nome a cui possiamo riferirci in seguito. Questo è particolarmente utile per verificarlo tramite dimostrazioni.

#+begin_src coq :session *coq*
  Proof. simpl. reflexivity. Qed.
#+end_src
 
** Booleani

Possiamo definire da zero il tipo boolean come:

#+begin_src coq :session *coq*
  Inductive bool : Type :=
  | true
  | false.

  (* E anche le funzioni booleane come prima*)
  Definition negb (b:bool) : bool :=
    match b with
    | true => false
    | false => true
    end.

  (* Possiamo anche avere più argomenti*)
  Definition andb (b1:bool) (b2:bool) : bool :=
    match b1 with
    | true => b2
    | false => false
    end.
  Definition orb (b1:bool) (b2:bool) : bool :=
    match b1 with
    | true => true
    | false => b2
    end.
#+end_src

Tramite ~Example~ possiamo scrivere delle specie di test unitari per mostrare che le tabelle di verità valgono.
 
#+begin_src coq :session *coq*
  Example test_orb1: (orb true false) = true.
  Proof. simpl. reflexivity. Qed.
  Example test_orb2: (orb false false) = false.
  Proof. simpl. reflexivity. Qed.
  Example test_orb3: (orb false true) = true.
  Proof. simpl. reflexivity. Qed.
  Example test_orb4: (orb true true) = true.
  Proof. simpl. reflexivity. Qed.
#+end_src

Tramite il comando ~Notation~ possiamo ridefinire la notazione con una a cui siamo più abituati ed è più leggibile.

#+begin_src coq :session *coq*
  Notation "x && y" := (andb x y).
  Notation "x || y" := (orb x y).
  Example test_orb5: false || false || true = true.
  Proof. simpl. reflexivity. Qed.
#+end_src

Introduciamo qui anche le espressioni condizionali, già viste in qualunque altro linguaggio di programmazione: ~if~ ~then~ ~else~ 

#+begin_src coq :session *coq*
  Definition negb' (b:bool) : bool :=
    if b then false
    else true.
  Definition andb' (b1:bool) (b2:bool) : bool :=
    if b1 then b2
    else false.
  Definition orb' (b1:bool) (b2:bool) : bool :=
    if b1 then true
    else b2.
#+end_src

Una nota interessante, siccome =bool= non è un tipo definito nativamente possiamo usare le espressioni condizionali su qualunque tipo che abbiamo definito induttivamente con esattamente due clausole nella sua definizione. La guardia è considerata =true= se valuta sul costruttore della prima clausola della definizione con ~Inductive~, mentre =false= se si valuta sulla seconda.

#+begin_src coq :session *coq*
  Inductive bw : Type :=
  | bw_black
  | bw_white.
  Definition invert (x: bw) : bw :=
    if x then bw_white
    else bw_black.
  Compute (invert bw_black).
  (* ==> bw_white : bw *)
  Compute (invert bw_white).
  (* ==> bw_black : bw *)
#+end_src

** Tipi

Ogni espressione in Rocq ha un tipo che descrive quello che sta computando. Il comando ~Check~ chiede a Rocq di stampare il tipo di un'espressione.

#+begin_src coq :session *coq*
  Check true.
  (* ===> true : bool *)
#+end_src

Possiamo anche dirgli il tipo che ci aspettiamo e se non corrisponde ritorna un errore.

#+begin_src coq :session *coq*
  Check true : bool.
  Check (negb true) : bool.
#+end_src

Funzioni come ~negb~ sono esse stesse valori (data) come =true= e =false=, il loro tipo è chiamato *function type* e si indica con la freccia "->".

#+begin_src coq :session *coq*
  Check negb : bool -> bool.
#+end_src

** Nuovi Tipi

I tipi che abbiamo definito fin'ora sono esempi di semplici "tipi enumerati", la loro definizione enumera esplicitamente un insieme finito di elementi detti =costruttori=. Vediamo adesso un tipo più interessante.

#+begin_src coq :session *coq*
  Inductive rgb : Type :=
  | red
  | green
  | blue.
  Inductive color : Type :=
  | black
  | white
  | primary (p : rgb).
#+end_src

Una definizione =Inductive= fa due cose principalmente
- Introduce una serie di nuovi costruttori come red, green, primary ...
- Li raggruppa in un nome unico come bool, rgb o color

=Espressioni di costruttori= sono formate applicando un costruttore a zero o più costruttori o altre espressioni, obbedendo comunque al numero e il tipo degli argomenti del costruttore.

Sono validi: red, true, primary red
*Non sono validi*: red primary, primary, true red, primary (primary red)
In particolare le definizioni di ~rgb~ e ~color~ ci dicono quali costruttori appartengono agli insiemi ~rgb~ e ~color~.

Possiamo definire funzioni tramite il =pattern matching= come abbiamo fatto per day e bool.

#+begin_src coq :session *coq*
  Definition monochrome (c : color) : bool :=
    match c with
    | black => true
    | white => true
    | primary p => false
    end.

  (* Possiamo forzare il matching con la costante red*)
  Definition isred (c : color) : bool :=
    match c with
    | black => false
    | white => false
    | primary red => true
    | primary _ => false 
    end.
#+end_src

Il simbolo `_` ci dice "il costruttore primary applicato a qualsiasi costruttore di =rgb= *tranne* =red=", ha lo stesso significato della variabile "dummy" ~p~ nel primo esempio.

** Moduli

In Rocq esistono moduli che useremo principalmente per evitare il clashing della nomenclatura di funzioni e variabili.

#+begin_src coq :session *coq*
  Module Playground.
    Definition foo : rgb := blue.
  End Playground.

  Definition foo : bool := true.

  Check Playground.foo : rgb.
  Check foo : bool.
#+end_src

** Tuple

Un singolo costruttore con molti parametri può essere utilizzato per creare dei tipi che sono tuple.

#+begin_src coq :session *coq*
  Module TuplePlayground.

    Inductive bit : Type :=
    | B1
    | B0.

    Inductive nybble : Type :=
    | bits (b0 b1 b2 b3 : bit).

    Check (bits B1 B0 B1 B0) : nybble.
#+end_src

Il costruttore ~bits~ fa da contenitore per il suo contenuto, è possibile unwrapparlo tramite pattern-matching.
Usiamo _ _ _ per evitare nome di variabili inutilizzate.

#+begin_src coq :session *coq*
  Definition all_zero (nb : nybble) : bool :=
    (* Controlla se tutti i bit sono B)*)
    match nb with
    | (bits B0 B0 B0 B0) => true
    | (bits _ _ _ _) => false
    end.

  Compute (all_zero (bits B1 B0 B1 B0)).
  (* ===> false : bool *)
  Compute (all_zero (bits B0 B0 B0 B0)).
  (* ===> true : bool *)
  End TuplePlayground.
#+end_src

**  Numeri

#+begin_src coq :session *coq*
  Module NatPlayground.
#+end_src

Uno dei capitoli più importanti, parliamo di numeri naturali. I numeri naturali al contrario dei tipi enumerati che abbiamo trattato fino ad adesso non sono finiti. Abbiamo bisogno di definirli in maniera più ricca.

Esistono molti metodi per rappresentare i numeri naturali, per aiutarci nelle dimostrazioni usiamo una rappresentazione molto semplice e molto famosa, la definizione formale degli =assiomi di Peano=.

   1. Esiste un numero naturale, 0, in Rocq lo indicheremo con il costruttore ~O~ (O grande).
   2. Ogni numero naturale ha un successore, lo indichiamo in Rocq con il costruttore ~S~ (n : nat)
   3. Numeri diversi hanno successori diversi.
   4. 0 non è il successore di alcun numero naturale.
   5. Ogni sottoinsieme di numeri naturali che contenga lo zero e il successore di ogni proprio elemento coincide con l'intero insieme dei numeri naturali (=assioma dell'induzione=)

      #+begin_src coq :session *coq* :session *coq*
	Inductive nat : Type :=
	| O
	| S (n : nat).
      #+end_src

   Con questa definizione "1" è rappresentato da S O, "2" da S (S O) e così via. *Induttivamente*.
   Possiamo quindi notare che tutti i numeri costruiti in questa maniera sono di =tipo= ~nat~.

   S e O sono un nome arbitrario che abbiamo dato a questi costruttori per /rappresentare/ i numeri naturali, un modo di scriverli. In questo modo possiamo dire che ogni numero naturale è costruibile come una sequenza di S che termina con un O.

   L'=interpretazione= di questi simboli dipende da come li usiamo per computare scrivendo funzioni che utilizzano il tipo ~nat~.

   #+begin_src coq :session *coq* :session *coq*
     Definition pred (n : nat) : nat :=
       match n with
       | O => O
       | S n' => n'
       end.
   #+end_src

   Il secondo ramo può essere letto come "Se n ha la forma S n' per qualche n' allora ritorna n'"
   Rocq qui ci viene incontro, siccome i numeri naturali sono un tipo di dato molto frequente possiamo usare la notazione comune dei numeri cardinali 1 2 3 4...

   #+begin_src coq :session *coq* :session *coq*
     Check (S (S (S (S O)))).
     (* ===> 4 : nat *)

     Definition minustwo (n : nat) : nat :=
       match n with
       | O => O
       | S O => O
       | S (S n') => n'
       end.
     Compute (minustwo 4).
     (* ===> 2 : nat *)
   #+end_src

   Il costruttore  S ha come tipo nat -> nat proprio come le funzioni  pred e minustwo

#+begin_src coq :session *coq* :session *coq*
Check S : nat → nat.
Check pred : nat → nat.
Check minustwo : nat → nat.
#+end_src

La differenza tra S e queste funzioni è che queste funzioni mappano dei numeri naturali a qualcos'altro computazionalmente (10 - 1 = 9)  mentre ~S~ non mappa niente, è solo un modo di scrivere i numeri naturali.

Come esempio il libro propone il numero =1= che da solo non rappresenta una computazione, è un dato o una parte di dato, se scriviamo =111= stiamo usando =1= tre volte per rappresentare il numero centoundici concretamente.

Per molte computazioni abbiamo bisogno del concetto di =ricorsione=. In Rocq definiamo le funzioni ricorsive tramite la keyword ~Fixpoint~ al posto di Definition.
Definiamo una funzione che calcola la parità di un numero naturale

#+begin_src  coq :session *coq*
Fixpoint even (n:nat) : bool :=
    match n with
    | O => true
    | S O => false
    | S (S n') => even n'
    end.
#+end_src

Possiamo anche definire ~odd~ allo stesso modo, ma esiste un metodo più intelligente come negazione della parità.

#+begin_src coq :session *coq* :session *coq*
Definition odd (n:nat) : bool :=
   negb (even n).

Example test_odd1: odd 1 = true.
   Proof. simpl. reflexivity. Qed.
Example test_odd2: odd 4 = false.
   Proof. simpl. reflexivity. Qed.
#+end_src

Naturalmente possiamo anche avere più argomenti in queste funzioni e per semplificare possiamo accorpare gli argomenti dello stesso tipo come segue.

#+begin_src coq :session *coq* :session *coq*
  Module NatPlayground2.
  Fixpoint plus (n : nat) (m : nat) : nat :=
     match n with
     | O => m
     | S n' => S (plus n' m)
     end.
  Fixpoint mult (n m : nat) : nat :=
     match n with
     | O => O
     | S n' => plus m (mult n' m)
     end.
  Example test_mult1: (mult 3 3) = 9.
     Proof. simpl. reflexivity. Qed.

  Fixpoint minus (n m:nat) : nat :=
     match n, m with
     | O , _ => O
     | S _ , O => n
     | S n', S m' => minus n' m'
     end.
   End NatPlayground2.

   Fixpoint exp (base power : nat) : nat :=
     match power with
     | O => S O
     | S p => mult base (exp base p)
     end.
 #+end_src

 Possiamo rendere le operazioni tra numeri naturali tramite la keyword ~Notation~.

 #+begin_src coq :session *coq* :session *coq*
   Notation "x + y" := (plus x y) (at level 50, left associativity) : nat_scope.
   Notation "x - y" := (minus x y) (at level 50, left associativity): nat_scope.
   Notation "x * y" := (mult x y) (at level 40, left associativity) : nat_scope.

   Check ((0 + 1) + 1) : nat.
 #+end_src

(level, associativity e nat_scope servono a Rocq per come tratta queste notazioni, al momento non è importante)

Rocq è così semplice che non ci viene dato nulla, nemmeno controllare l'uguaglianza tra due numeri naturali è scontato.

#+begin_src coq :session *coq*
Fixpoint eqb (n m : nat) : bool :=
  match n with
  | O => match m with
         | O => true
         | S m' => false
         end
  | S n' => match m with
            | O => false
            | S m' => eqb n' m'
            end
  end.
#+end_src

O la comparazione tra numeri

#+begin_src coq :session *coq*
Fixpoint leb (n m : nat) : bool :=
  match n with
  | O => true
  | S n' =>
      match m with
      | O => false
      | S m' => leb n' m'
      end
  end.

Example test_leb1: leb 2 2 = true.
  Proof. simpl. reflexivity. Qed.
Example test_leb2: leb 2 4 = true.
  Proof. simpl. reflexivity. Qed.
Example test_leb3: leb 4 2 = false.
  Proof. simpl. reflexivity. Qed.

Notation "x =? y" := (eqb x y) (at level 70) : nat_scope.
Notation "x <=? y" := (leb x y) (at level 70) : nat_scope.

Example test_leb3': (4 <=? 2) = false.
  Proof. simpl. reflexivity. Qed.
#+end_src

* Dimostrazioni
**  Dimostrazioni tramite Semplificazione

Ora che abbiamo definito alcuni tipi di dati e funzioni possiamo iniziare a scrivere dimostrazioni.

Nei vari ~Example~ abbiamo già iniziato a farlo, qui viene spiegato quello che succede in questi casi e come costruire alcuni tipi di dimostrazioni.

Abbiamo usato  la keyword ~simpl~ per simplificare entrambi i lati di un'equazione e la keyword ~reflexivity~ per controllare che entrambi i lati contengono valori identici.

#+begin_src coq :session *coq* :session *coq*
Example plus_1_1 : 1 + 1 = 2.
Proof. simpl. reflexivity. Qed.
#+end_src
 
Possiamo usare lo stesso tipo di dimostrazione anche per casi più interessanti, ad esempio per dimostrare che 0 è l'elemento neutro dell'addizione.

Per dimostrare che 0 + n = n possiamo osservare che nella definizione di addizione si riduce sempre ad n a destra.

#+begin_src  coq
Theorem plus_O_n : forall n : nat, 0 + n = n.
Proof.
  intros n. simpl. reflexivity. Qed.
#+end_src

Una piccola nota, in questo caso ~simpl~ è ridondante siccome ~reflexivity~ si occupa di fare qualche tipo di semplificazione automaticamente quando controlla che entrambi i lati sono identici.
 
In questo caso usiamo ~Theorem~ invece che ~Example~ puramente per questioni di stile, altre keyword derivano dalle dimostrazioni classiche "a mano" e sono ~Lemma~, ~Fact~, ~Remark~, ~Corollary~ etc. in Rocq hanno esattamente lo stesso significato.

Il quantificatore universale ~forall~ n : nat serve a dire che il nostro teorema vale per **qualunque** numero naturale n, in maniera informale diremmo "Supponiamo che n sia un qualunque numero naturale ...", quest'ultima frase è racchiusa nella keyword ~intro~, nel caso vogliamo introdurre più variabili allora si usa la keyword ~intros~, che si occupano di spostarci dal quantificatore universale del goal al *contesto* delle *supposizioni correnti*.
Potremmo dare qualunque nome vogliamo alla variabile, abbiamo scelto di mantenere n per evitare confusione.

#+begin_src coq :session *coq* :session *coq*
Theorem plus_O_n'' : forall n : nat, 0 + n = n.
Proof.
  intros m. reflexivity. Qed.
#+end_src

~Proof.~ e ~Qed.~ sono anch'esse keyword stilistiche che servono a racchiudere la nostra dimostrazione.

(Qed. dal latino /Quod Erat Demonstrandum/ "come volevasi dimostrare", frase comunemente utilizzata per indicare che una dimostrazione è terminata.) 

~simpl.~ ~intros~ e ~reflexivity~ sono esempi di *tattiche*. Una tattica è un comando utilizzato in una dimostrazione per guidare il processo in cui cerchiamo di controllare la validità di un'affermazione che stiamo facendo.

#+begin_src coq :session *coq* :session *coq*
 Theorem plus_1_l : forall n:nat, 1 + n = S n.
Proof.
  intros n. reflexivity. Qed.
Theorem mult_0_l : forall n:nat, 0 × n = 0.
Proof.
  intros n. reflexivity. Qed.
#+end_src

Il suffisso "_l" è da leggere come "a sinistra", nell'esempio "addizione a 1 a sinistra" e "moltiplicazione per zero a sinistra".

** Dimostrazioni tramite Riscrittura

Il libro presenta un teorema leggermente più interessante rispetto quelli visti fin'ora

#+begin_src coq :session *coq* :session *coq*
Theorem plus_id_example : forall n m : nat,
  n = m ->
  n + n = m + m.
#+end_src

Invece di prendere qualsiasi numero naturale m e qualsiasi numero natural n in questo caso stiamo specificando che n = m. Il simbolo -> indica l'implicazione logica.

In questo caso oltre ad assumere l'esistenza di uno specifico n e uno specifico m naturali dobbiamo anche introdurre l'ipotesi per cui m = n. Anche queste ipotesi possono essere introdotte nel contesto tramite la keyword ~intros~.

Siccome m e n sono numeri arbitrari non basta semplificare per dimostrare la nostra assunzione,  però possiamo provare a sostituire m con n e vedere se otteniamo due espressioni identiche da entrambi i lati.

Per fare "sostituzioni" utilizziamo la keyword ~rewrite~ con una freccia che indica da che lato va eseguita la sostituzione, ad esempio m -> n (sostituiamo la parte sinista con la parte desta) oppure m <- n il viceversa.

#+begin_src coq :session *coq* :session *coq*
  Theorem plus_id_example : forall n m : nat,
    n = m ->
    n + n = m + m.
    Proof.
      (* move both quantifiers into the context: *)
      intros n m.
      (* move the hypothesis into the context: *)
      intros H.
      (* rewrite the goal using the hypothesis: *)
      rewrite -> H.
      reflexivity. Qed.
#+end_src

In questa dimostrazione introduciamo n e m e l'ipotesi H per cui m = n, proviamo a sostituire n con la parte destra m e otteniamo (m + m) = (m + m) che è identica da entrambi i lati, per cui usiamo la strategia reflexivity.

Nota che -> non ha nulla a che fare con l'implicazione!

#+begin_src coq :session *coq* :session *coq*
  Theorem plus_id_example : forall n m : nat,
    n = m ->
    n + n = m + m.
  Proof.
    intros n m.
    intros H.
    (* Abbiamo invertito la freccia*)
    rewrite <- H.
    reflexivity. Qed.
#+end_src

Introduciamo la keywoard ~Admitted~ utilizzata negli esercizi, non fa altro che dire a Rocq che la dimostrazione è incompleta e la diamo per valida per ora per non fermare il flusso della valutazione del testo. Attenzione che potrebbe lasciare Rocq in uno stato insicuro. (I libro non elabora oltre)

La keyword ~Check~ può essere utilizzata per esaminare affermazioni di Lemma e Teoremi precedenemente dichiarati.

#+begin_src coq :session *coq*
Check mult_n_O.
(* ===> forall n : nat, 0 = n * 0 *)
Check mult_n_Sm.
(* ===> forall n m : nat, n * m + n = n * S m *)
#+end_src

Possiamo usare la ~rewrite~ per utilizzare teoremi precedentemente dimostrati all'interno della nostra dimostrazione al posto delle ipotesi, Rocq tenta di fare correttamente il matching con le variabili del nostro contesto.

#+begin_src coq :session *coq*
Theorem mult_n_0_m_0 : forall p q : nat,
  (p * 0) + (q * 0) = 0.
Proof.
  intros p q.
  rewrite <- mult_n_O.
  rewrite <- mult_n_O.
  reflexivity. Qed.
#+end_src

** Dimostrazioni tramite Analisi dei Casi

Per dimostrazioni più complicate le tattiche viste fin'ora non bastano, soprattutto quando abbiamo valori generali e ipotetici che possono bloccare la semplificazione.

#+begin_src coq :session *coq*

Theorem plus_1_neq_0_firsttry : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros n.
  simpl. (* does nothing! *)
Abort.
#+end_src

Abbiamo usato ~Abort~ per dire a Rocq che al momento ci arrendiamo al dimostrare questo teorema. Al contrario di ~Admitted~ ci impedisce di utilizzare questo teorema in successive dimostrazioni (non lo stiamo ammettendo).

Il motivo per cui la dimostrazione rimane bloccata è che sia eqb che + iniziano provando a fare matching sul primo argomento, ma il primo argomento di + è un valore sconosciuto e l'argomento di eqb è l'espressione composta n + 1.

Per poter continuare dobbiamo quindi chiederci quali sono le forme che può avere n, separatamente, per casi.
- Se n è 0 allora (n + 1) =? 0 non può essere vera
- Se n è un'espression S n' per qualche n' allora sapendo che *almeno* ha davanti un *S* è il successore di qualcosa, pur non sapendo che cosa questo "qualcosa" sia possiamo dire per certo che sommando 1 non otteniamo 0 e quindi l'affermazione è comunque falsa.

La tattica che si usa in Rocq per distinguere questi casi è ~destruct~.

#+begin_src coq :session *coq*
Theorem plus_1_neq_0 : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros n. destruct n as [| n'] eqn:E.
  - reflexivity.
  - reflexivity. Qed.
#+end_src

La tattica ~destruct~ ha generato in questo esempio due *casi*, o sotto-goal, per semplicità possiamo racchiudere questi sotto-goal con delle liste puntate, in modo tale da distringuere facilmente i due *scope* tramite una notazione a *bullet*. Ogni bullet è da dimostrare separatamente dall'altro per questo diciamo che sono *scopi* differenti.

Se non inseriamo la notazione a bullet Rocq si aspetta che dimostriamo ogni subgoal in sequenza uno alla volta, ma è buona norma inserirli per migliorare la leggibilità, soprattutto quando ogni sottogoal inizia a sua volta ad avere altri sottogoal.

La notazione `as [| n']` invece è chiamata =intro pattern=, dice a Rocq i nomi di variabile da introdurre per ogni sottogoal. In generale tra le parentesi quadre viene inserita una /lista di liste/ di nomi, separati da |. In questo caso il primo componente è vuoto *siccome il costruttore O non prende argomenti*, mentre siccome *S* è un operatore unario diamo come nome del suo argomento n'.

In ogni sottogoal Rocq si ricorda l'assunzione riguardante n inerente a quel sottogoal, ovvero il fatto che o n = O oppure n = S n' per qualche n'. l'annotazione eqn:E dice alla destruct di dare il nome E a questa equazione.

*ATTENZIONE*: Se viene omesso eqn:E Rocq ignora questa assunzione nei sottogoal, mentre questo può essere utile in alcuni casi (ad esempio in dimostrazioni in cui queste assunzioni non sono utili) è sempre buona pratica metterlo.
 
La tattica ~destruct~ può essere utilizzata con ogni tipo di dato definito induttivamente. Nell'esempio viene dimostrata l'involuzione della negazione. (la negazione è la sua inversa)

#+begin_src  coq :session *coq*
 Theorem negb_involutive : forall b : bool,
  negb (negb b) = b.
Proof.
  intros b. destruct b eqn:E.
  - reflexivity.
  - reflexivity. Qed.
#+end_src

Notare che siccome nessun sottocaso ha bisogno di associare variabili non vengono specificati nomi. Inoltre, se non specifichiamo i nomi in qualunque destruct Rocq si occuperà di inventarseli, generalmente è da evitare.

Un esempio in cui abbiamo subgoal che a loro volta generano subgoal

#+begin_src coq :session *coq*
Theorem andb_commutative : forall b c, andb b c = andb c b.
Proof.
  intros b c. destruct b eqn:Eb.
  - destruct c eqn:Ec.
    + reflexivity.
    + reflexivity.
  - destruct c eqn:Ec.
    + reflexivity.
    + reflexivity.
Qed.
#+end_src

Come *bullet* si possono usare -, + e ogni sequenza di asterischi \*\*\*. Oppure in alternativa delle parentesi graffe.
Ed è possibile combinarli insieme in base alla preferenza.

#+begin_src coq :session *coq*
Theorem andb_commutative' : forall b c, andb b c = andb c b.
Proof.
  intros b c. destruct b eqn:Eb.
  { destruct c eqn:Ec.
    { reflexivity. }
    { reflexivity. } }
  { destruct c eqn:Ec.
    { reflexivity. }
    { reflexivity. } }
Qed.

Theorem andb3_exchange :
  forall b c d, andb (andb b c) d = andb (andb b d) c.
Proof.
  intros b c d. destruct b eqn:Eb.
  - destruct c eqn:Ec.
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
  - destruct c eqn:Ec.
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
Qed.
#+end_src

Un'ultima nota che aggiunge il libro, siccome spesso le dimostrazioni fanno analisi per casi su variabili appena introdotte, Rocq aggiunge una comodità.

Invece di 

#+begin_src  coq
intros x y. destruct y as [|y] eqn:E.
#+end_src

Possiamo introdurre il pattern direttamente in ~intros~

#+begin_src coq :session *coq*
Theorem plus_1_neq_0' : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros [|n].
  - reflexivity.
  - reflexivity. Qed.
#+end_src

E se non ci sono costruttori possiamo direttamente usare [] per iniziare l'analisi per casi direttamente.

#+begin_src coq :session *coq*
Theorem andb_commutative'' :
  forall b c, andb b c = andb c b.
Proof.
  intros [] [].
  - reflexivity.
  - reflexivity.
  - reflexivity.
  - reflexivity.
Qed.
#+end_src

Alcune note veloci sui sottocapitoli "opzionali"

#+begin_src coq :session *coq*
 Notation "x + y" := (plus x y)
                       (at level 50, left associativity)
                       : nat_scope.
Notation "x * y" := (mult x y)
                       (at level 40, left associativity)
                       : nat_scope.
#+end_src

Qui level indica il livello di precedenza dell'operatore per disambiguare casi come 1+2*3*4 e dare precedenza agli operatori. Alcuni valori che può usare sono da 0 a 100, left, right, o no associativity.
Invece nat_scope serve ad aiutare Rocq a capire lo scopo dell'operatore dal contesto, quando vede S (O * O) capisce che è nat_scope mentre se dovesse vedere una coppia bool*bool allora indovinerebbe type_scope. Spesso il contesto della notazione è ambiguo e va aiutato come nel caso (x×y)%nat.

#+begin_src coq :session *coq*
  Fixpoint plus' (n : nat) (m : nat) : nat :=
    match n with
    | O => m
    | S n' => S (plus' n' m)
    end.
#+end_src

In questa notazione della somma Rocq si rende conto che plus` "decresce sul primo argomento" questo significa che sta eseguendo una "ricorsione strutturale" sull'argomento n. Ovvero esegue chiamate di funzione solo su valori strettamente più piccoli di n, in questo modo si assicura che la funzione ricorsiva eventualmente termina (in Rocq è garantito che ogni funzione termina). Ogni definizione ~Fixpoint~ in Rocq deve essere /decrescente/ in questa maniera. Il problema è che l'analisi che fa Rocq per comprendere se queste funzioni sono decrescenti non è molto sofisticata spesso bisogna riscrivere le funzioni in maniera poco intuitiva.

* Induzione


