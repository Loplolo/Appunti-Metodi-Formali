#+PROPERTY: header-args:coq :session *coq*
* Disclaimer

Questi appunti seguono il primo volume di  *Software Foundations* scritto a vari mani che può essere letto nella sua interezza qui: [[https://softwarefoundations.cis.upenn.edu/][Software Foundations]]. Gli appunti sono un riassunto  di alcuni degli argomenti trattati durante il corso di *Metodi Formali* tenuto dal prof. Momigliano dell'Università degli Studi di Milano.

Disclaimer: Sono sicuro al 100% di commettere errori, è la prima volta che mi approccio all'argomento e non ho il tempo per rileggere quello che ho scritto, questi appunti sono rilasciati sotto licenza MIT senza violare il copyright degli scrittori originali.

* Introduzione a rocq

Rocq (conosciuto precedentemente come coq) è un _proof-assistant_, ovvero uno strumento utilizzato per formalizzare concetti matematici, dimostrare teoremi e verificare la correttezza di algoritmi e programmi.

Un *proof-assistant* permette di sviluppare dimostrazioni matematiche in garantendo maggiore affidabilità rispetto alle verifiche manuali.

Rocq usa come linguaggio formale "*Gallina*" per scrivere definizioni, algoritmi eseguibili e teoremi. È utilizzato nell'informatica teorica per la formalizzazione del software, per assicurare che un programma si comporti esattamente secondo le sue specifiche. È inoltre possibile generare automaticamente codice OCaml o Haskell a partire dalle specifiche verificate.

Il linguaggio di programmazione di Rocq, Gallina, è un linguaggio funzionale. Lo stile funzionale in programmazione ha fondamenti matematici, se una procedura non ha _effetti collaterali_ allora tutto quello che ci interessa è che associ un *input* ad un *output*. I linguaggi funzionali trattano le funzioni come "*first-class values*" ovvero sono esse stesse valori che possono essere passati ad altre funzioni, ogni funzione può essere trattata come *data*.

* Fondamenti
** Tipi enumerati

Una delle caratteristiche di Rocq è che include un numero estremamente limitato di feature built-in. Per esempio invece dei soli ti tipi atomici (booleani, interi, stringhe, ...) invece usa un meccanismo per definire nuovi tipi. Nonostante questo esistono molte librerie che "fanno il lavoro sporco" per noi introducendo tipi comuni utili per le nostre dimostrazioni come la libreria standard *Stdlib*.

Vediamo un esempio del meccanismo di definizione dei tipi.

#+begin_src coq :session *coq*
  Inductive day : Type :=
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday
  | sunday.
#+end_src

Possiamo quindi scrivere funzioni che usano il tipo che abbiamo appena creato. Utilizzando il pattern matching con ~match~ .. ~with~ ... ~end~

#+begin_src coq :session *coq*
  Definition next_working_day (d:day) : day :=
    match d with
    | monday => tuesday
    | tuesday => wednesday
    | wednesday => thursday
    | thursday => friday
    | friday => monday
    | saturday => monday
    | sunday => monday
    end.
#+end_src

Foreshadowing che mi pareva giusto inserire qui, è possibile fare matching di più valori allo stesso tempo per non riscrivere la stessa cosa più volte.

#+begin_src coq :session *coq*
  Definition month_to_season (m : month) : season :=
    match m with
    | March | April | May => Spring
    | June | July | August => Summer
    | September| October | November => Autumn
    | December | January | February => Winter 
    end.
#+end_src
  
Notare che gli argomenti e i valori ritornati sono dichiarati esplicitamente nella prima riga, come molti linguaggi Rocq può fare inferenza di tipo da solo se non sono esplicitati, ma è buona pratica includerli sempre.

Possiamo valutare una funzione con il comando ~Compute~

#+begin_src coq :session *coq*
  Compute (next_working_day friday).
  (* ==> monday : day *)
  Compute (next_working_day (next_working_day saturday)).
  (* ==> tuesday : day *)
#+end_src

Tramite il comando ~Example~ possiamo invece testare qual è il risultato che ci aspettiamo da una funzione.

#+begin_src coq :session *coq*
  Example test_next_working_day:
    (next_working_day (next_working_day saturday)) = tuesday.
#+end_src

~Example~ crea un'*asserzione* e gli da un nome a cui possiamo riferirci in seguito. Questo è particolarmente utile per verificarlo tramite dimostrazioni.

#+begin_src coq :session *coq*
  Proof. simpl. reflexivity. Qed.
#+end_src
 
** Booleani

Possiamo definire da zero il tipo boolean come:

#+begin_src coq :session *coq*
  Inductive bool : Type :=
  | true
  | false.

  (* E anche le funzioni booleane come prima*)
  Definition negb (b:bool) : bool :=
    match b with
    | true => false
    | false => true
    end.

  (* Possiamo anche avere più argomenti*)
  Definition andb (b1:bool) (b2:bool) : bool :=
    match b1 with
    | true => b2
    | false => false
    end.
  Definition orb (b1:bool) (b2:bool) : bool :=
    match b1 with
    | true => true
    | false => b2
    end.
#+end_src

Tramite ~Example~ possiamo scrivere delle specie di test unitari per mostrare che le tabelle di verità valgono.
 
#+begin_src coq :session *coq*
  Example test_orb1: (orb true false) = true.
  Proof. simpl. reflexivity. Qed.
  Example test_orb2: (orb false false) = false.
  Proof. simpl. reflexivity. Qed.
  Example test_orb3: (orb false true) = true.
  Proof. simpl. reflexivity. Qed.
  Example test_orb4: (orb true true) = true.
  Proof. simpl. reflexivity. Qed.
#+end_src

Tramite il comando ~Notation~ possiamo ridefinire la notazione con una a cui siamo più abituati ed è più leggibile.

#+begin_src coq :session *coq*
  Notation "x && y" := (andb x y).
  Notation "x || y" := (orb x y).
  Example test_orb5: false || false || true = true.
  Proof. simpl. reflexivity. Qed.
#+end_src

Introduciamo qui anche le espressioni condizionali, già viste in qualunque altro linguaggio di programmazione: ~if~ ~then~ ~else~ 

#+begin_src coq :session *coq*
  Definition negb' (b:bool) : bool :=
    if b then false
    else true.
  Definition andb' (b1:bool) (b2:bool) : bool :=
    if b1 then b2
    else false.
  Definition orb' (b1:bool) (b2:bool) : bool :=
    if b1 then true
    else b2.
#+end_src

Una nota interessante, siccome =bool= non è un tipo definito nativamente possiamo usare le espressioni condizionali su qualunque tipo che abbiamo definito induttivamente con esattamente due clausole nella sua definizione. La guardia è considerata =true= se valuta sul costruttore della prima clausola della definizione con ~Inductive~, mentre =false= se si valuta sulla seconda.

#+begin_src coq :session *coq*
  Inductive bw : Type :=
  | bw_black
  | bw_white.
  Definition invert (x: bw) : bw :=
    if x then bw_white
    else bw_black.
  Compute (invert bw_black).
  (* ==> bw_white : bw *)
  Compute (invert bw_white).
  (* ==> bw_black : bw *)
#+end_src

** Tipi

Ogni espressione in Rocq ha un tipo che descrive quello che sta computando. Il comando ~Check~ chiede a Rocq di stampare il tipo di un'espressione.

#+begin_src coq :session *coq*
  Check true.
  (* ===> true : bool *)
#+end_src

Possiamo anche dirgli il tipo che ci aspettiamo e se non corrisponde ritorna un errore.

#+begin_src coq :session *coq*
  Check true : bool.
  Check (negb true) : bool.
#+end_src

Funzioni come ~negb~ sono esse stesse valori (data) come =true= e =false=, il loro tipo è chiamato *function type* e si indica con la freccia "->".

#+begin_src coq :session *coq*
  Check negb : bool -> bool.
#+end_src

** Nuovi Tipi

I tipi che abbiamo definito fin'ora sono esempi di semplici "tipi enumerati", la loro definizione enumera esplicitamente un insieme finito di elementi detti =costruttori=. Vediamo adesso un tipo più interessante.

#+begin_src coq :session *coq*
  Inductive rgb : Type :=
  | red
  | green
  | blue.
  Inductive color : Type :=
  | black
  | white
  | primary (p : rgb).
#+end_src

Una definizione =Inductive= fa due cose principalmente
- Introduce una serie di nuovi costruttori come red, green, primary ...
- Li raggruppa in un nome unico come bool, rgb o color

=Espressioni di costruttori= sono formate applicando un costruttore a zero o più costruttori o altre espressioni, obbedendo comunque al numero e il tipo degli argomenti del costruttore.

Sono validi: red, true, primary red
*Non sono validi*: red primary, primary, true red, primary (primary red)
In particolare le definizioni di ~rgb~ e ~color~ ci dicono quali costruttori appartengono agli insiemi ~rgb~ e ~color~.

Possiamo definire funzioni tramite il =pattern matching= come abbiamo fatto per day e bool.

#+begin_src coq :session *coq*
  Definition monochrome (c : color) : bool :=
    match c with
    | black => true
    | white => true
    | primary p => false
    end.

  (* Possiamo forzare il matching con la costante red*)
  Definition isred (c : color) : bool :=
    match c with
    | black => false
    | white => false
    | primary red => true
    | primary _ => false 
    end.
#+end_src

Il simbolo `_` ci dice "il costruttore primary applicato a qualsiasi costruttore di =rgb= *tranne* =red=", ha lo stesso significato della variabile "dummy" ~p~ nel primo esempio.

** Moduli

In Rocq esistono moduli che useremo principalmente per evitare il clashing della nomenclatura di funzioni e variabili.

#+begin_src coq :session *coq*
  Module Playground.
    Definition foo : rgb := blue.
  End Playground.

  Definition foo : bool := true.

  Check Playground.foo : rgb.
  Check foo : bool.
#+end_src

** Tuple

Un singolo costruttore con molti parametri può essere utilizzato per creare dei tipi che sono tuple.

#+begin_src coq :session *coq*
  Module TuplePlayground.

    Inductive bit : Type :=
    | B1
    | B0.

    Inductive nybble : Type :=
    | bits (b0 b1 b2 b3 : bit).

    Check (bits B1 B0 B1 B0) : nybble.
#+end_src

Il costruttore ~bits~ fa da contenitore per il suo contenuto, è possibile unwrapparlo tramite pattern-matching.
Usiamo _ _ _ per evitare nome di variabili inutilizzate.

#+begin_src coq :session *coq*
  Definition all_zero (nb : nybble) : bool :=
    (* Controlla se tutti i bit sono B)*)
    match nb with
    | (bits B0 B0 B0 B0) => true
    | (bits _ _ _ _) => false
    end.

  Compute (all_zero (bits B1 B0 B1 B0)).
  (* ===> false : bool *)
  Compute (all_zero (bits B0 B0 B0 B0)).
  (* ===> true : bool *)
  End TuplePlayground.
#+end_src

**  Numeri

#+begin_src coq :session *coq*
  Module NatPlayground.
#+end_src

Uno dei capitoli più importanti, parliamo di numeri naturali. I numeri naturali al contrario dei tipi enumerati che abbiamo trattato fino ad adesso non sono finiti. Abbiamo bisogno di definirli in maniera più ricca.

Esistono molti metodi per rappresentare i numeri naturali, per aiutarci nelle dimostrazioni usiamo una rappresentazione molto semplice e molto famosa, la definizione formale degli =assiomi di Peano=.

   1. Esiste un numero naturale, 0, in Rocq lo indicheremo con il costruttore ~O~ (O grande).
   2. Ogni numero naturale ha un successore, lo indichiamo in Rocq con il costruttore ~S~ (n : nat)
   3. Numeri diversi hanno successori diversi.
   4. 0 non è il successore di alcun numero naturale.
   5. Ogni sottoinsieme di numeri naturali che contenga lo zero e il successore di ogni proprio elemento coincide con l'intero insieme dei numeri naturali (=assioma dell'induzione=)

      #+begin_src coq :session *coq* :session *coq*
	Inductive nat : Type :=
	| O
	| S (n : nat).
      #+end_src

   Con questa definizione "1" è rappresentato da S O, "2" da S (S O) e così via. *Induttivamente*.
   Possiamo quindi notare che tutti i numeri costruiti in questa maniera sono di =tipo= ~nat~.

   S e O sono un nome arbitrario che abbiamo dato a questi costruttori per /rappresentare/ i numeri naturali, un modo di scriverli. In questo modo possiamo dire che ogni numero naturale è costruibile come una sequenza di S che termina con un O.

   L'=interpretazione= di questi simboli dipende da come li usiamo per computare scrivendo funzioni che utilizzano il tipo ~nat~.

   #+begin_src coq :session *coq* :session *coq*
     Definition pred (n : nat) : nat :=
       match n with
       | O => O
       | S n' => n'
       end.
   #+end_src

   Il secondo ramo può essere letto come "Se n ha la forma S n' per qualche n' allora ritorna n'"
   Rocq qui ci viene incontro, siccome i numeri naturali sono un tipo di dato molto frequente possiamo usare la notazione comune dei numeri cardinali 1 2 3 4...

   #+begin_src coq :session *coq* :session *coq*
     Check (S (S (S (S O)))).
     (* ===> 4 : nat *)

     Definition minustwo (n : nat) : nat :=
       match n with
       | O => O
       | S O => O
       | S (S n') => n'
       end.
     Compute (minustwo 4).
     (* ===> 2 : nat *)
   #+end_src

   Il costruttore  S ha come tipo nat -> nat proprio come le funzioni  pred e minustwo

#+begin_src coq :session *coq* :session *coq*
Check S : nat → nat.
Check pred : nat → nat.
Check minustwo : nat → nat.
#+end_src

La differenza tra S e queste funzioni è che queste funzioni mappano dei numeri naturali a qualcos'altro computazionalmente (10 - 1 = 9)  mentre ~S~ non mappa niente, è solo un modo di scrivere i numeri naturali.

Come esempio il libro propone il numero =1= che da solo non rappresenta una computazione, è un dato o una parte di dato, se scriviamo =111= stiamo usando =1= tre volte per rappresentare il numero centoundici concretamente.

Per molte computazioni abbiamo bisogno del concetto di =ricorsione=. In Rocq definiamo le funzioni ricorsive tramite la keyword ~Fixpoint~ al posto di Definition.
Definiamo una funzione che calcola la parità di un numero naturale

#+begin_src  coq :session *coq*
Fixpoint even (n:nat) : bool :=
    match n with
    | O => true
    | S O => false
    | S (S n') => even n'
    end.
#+end_src

Possiamo anche definire ~odd~ allo stesso modo, ma esiste un metodo più intelligente come negazione della parità.

#+begin_src coq :session *coq* :session *coq*
Definition odd (n:nat) : bool :=
   negb (even n).

Example test_odd1: odd 1 = true.
   Proof. simpl. reflexivity. Qed.
Example test_odd2: odd 4 = false.
   Proof. simpl. reflexivity. Qed.
#+end_src

Naturalmente possiamo anche avere più argomenti in queste funzioni e per semplificare possiamo accorpare gli argomenti dello stesso tipo come segue.

#+begin_src coq :session *coq* :session *coq*
  Module NatPlayground2.
  Fixpoint plus (n : nat) (m : nat) : nat :=
     match n with
     | O => m
     | S n' => S (plus n' m)
     end.
  Fixpoint mult (n m : nat) : nat :=
     match n with
     | O => O
     | S n' => plus m (mult n' m)
     end.
  Example test_mult1: (mult 3 3) = 9.
     Proof. simpl. reflexivity. Qed.

  Fixpoint minus (n m:nat) : nat :=
     match n, m with
     | O , _ => O
     | S _ , O => n
     | S n', S m' => minus n' m'
     end.
   End NatPlayground2.

   Fixpoint exp (base power : nat) : nat :=
     match power with
     | O => S O
     | S p => mult base (exp base p)
     end.
 #+end_src

 Possiamo rendere le operazioni tra numeri naturali tramite la keyword ~Notation~.

 #+begin_src coq :session *coq* :session *coq*
   Notation "x + y" := (plus x y) (at level 50, left associativity) : nat_scope.
   Notation "x - y" := (minus x y) (at level 50, left associativity): nat_scope.
   Notation "x * y" := (mult x y) (at level 40, left associativity) : nat_scope.

   Check ((0 + 1) + 1) : nat.
 #+end_src

(level, associativity e nat_scope servono a Rocq per come tratta queste notazioni, al momento non è importante)

Rocq è così semplice che non ci viene dato nulla, nemmeno controllare l'uguaglianza tra due numeri naturali è scontato.

#+begin_src coq :session *coq*
Fixpoint eqb (n m : nat) : bool :=
  match n with
  | O => match m with
         | O => true
         | S m' => false
         end
  | S n' => match m with
            | O => false
            | S m' => eqb n' m'
            end
  end.
#+end_src

O la comparazione tra numeri

#+begin_src coq :session *coq*
Fixpoint leb (n m : nat) : bool :=
  match n with
  | O => true
  | S n' =>
      match m with
      | O => false
      | S m' => leb n' m'
      end
  end.

Example test_leb1: leb 2 2 = true.
  Proof. simpl. reflexivity. Qed.
Example test_leb2: leb 2 4 = true.
  Proof. simpl. reflexivity. Qed.
Example test_leb3: leb 4 2 = false.
  Proof. simpl. reflexivity. Qed.

Notation "x =? y" := (eqb x y) (at level 70) : nat_scope.
Notation "x <=? y" := (leb x y) (at level 70) : nat_scope.

Example test_leb3': (4 <=? 2) = false.
  Proof. simpl. reflexivity. Qed.
#+end_src

* Dimostrazioni
**  Dimostrazioni tramite Semplificazione

Ora che abbiamo definito alcuni tipi di dati e funzioni possiamo iniziare a scrivere dimostrazioni.

Nei vari ~Example~ abbiamo già iniziato a farlo, qui viene spiegato quello che succede in questi casi e come costruire alcuni tipi di dimostrazioni.

Abbiamo usato  la keyword ~simpl~ per simplificare entrambi i lati di un'equazione e la keyword ~reflexivity~ per controllare che entrambi i lati contengono valori identici.

#+begin_src coq :session *coq* :session *coq*
Example plus_1_1 : 1 + 1 = 2.
Proof. simpl. reflexivity. Qed.
#+end_src
 
Possiamo usare lo stesso tipo di dimostrazione anche per casi più interessanti, ad esempio per dimostrare che 0 è l'elemento neutro dell'addizione.

Per dimostrare che 0 + n = n possiamo osservare che nella definizione di addizione si riduce sempre ad n a destra.

#+begin_src  coq
Theorem plus_O_n : forall n : nat, 0 + n = n.
Proof.
  intros n. simpl. reflexivity. Qed.
#+end_src

Una piccola nota, in questo caso ~simpl~ è ridondante siccome ~reflexivity~ si occupa di fare qualche tipo di semplificazione automaticamente quando controlla che entrambi i lati sono identici.
 
In questo caso usiamo ~Theorem~ invece che ~Example~ puramente per questioni di stile, altre keyword derivano dalle dimostrazioni classiche "a mano" e sono ~Lemma~, ~Fact~, ~Remark~, ~Corollary~ etc. in Rocq hanno esattamente lo stesso significato.

Il quantificatore universale ~forall~ n : nat serve a dire che il nostro teorema vale per **qualunque** numero naturale n, in maniera informale diremmo "Supponiamo che n sia un qualunque numero naturale ...", quest'ultima frase è racchiusa nella keyword ~intro~, nel caso vogliamo introdurre più variabili allora si usa la keyword ~intros~, che si occupano di spostarci dal quantificatore universale del goal al *contesto* delle *supposizioni correnti*.
Potremmo dare qualunque nome vogliamo alla variabile, abbiamo scelto di mantenere n per evitare confusione.

#+begin_src coq :session *coq* :session *coq*
Theorem plus_O_n'' : forall n : nat, 0 + n = n.
Proof.
  intros m. reflexivity. Qed.
#+end_src

~Proof.~ e ~Qed.~ sono anch'esse keyword stilistiche che servono a racchiudere la nostra dimostrazione.

(Qed. dal latino /Quod Erat Demonstrandum/ "come volevasi dimostrare", frase comunemente utilizzata per indicare che una dimostrazione è terminata.) 

~simpl.~ ~intros~ e ~reflexivity~ sono esempi di *tattiche*. Una tattica è un comando utilizzato in una dimostrazione per guidare il processo in cui cerchiamo di controllare la validità di un'affermazione che stiamo facendo.

#+begin_src coq :session *coq* :session *coq*
 Theorem plus_1_l : forall n:nat, 1 + n = S n.
Proof.
  intros n. reflexivity. Qed.
Theorem mult_0_l : forall n:nat, 0 × n = 0.
Proof.
  intros n. reflexivity. Qed.
#+end_src

Il suffisso "_l" è da leggere come "a sinistra", nell'esempio "addizione a 1 a sinistra" e "moltiplicazione per zero a sinistra".

** Dimostrazioni tramite Riscrittura

Il libro presenta un teorema leggermente più interessante rispetto quelli visti fin'ora

#+begin_src coq :session *coq* :session *coq*
Theorem plus_id_example : forall n m : nat,
  n = m ->
  n + n = m + m.
#+end_src

Invece di prendere qualsiasi numero naturale m e qualsiasi numero natural n in questo caso stiamo specificando che n = m. Il simbolo -> indica l'implicazione logica.

In questo caso oltre ad assumere l'esistenza di uno specifico n e uno specifico m naturali dobbiamo anche introdurre l'ipotesi per cui m = n. Anche queste ipotesi possono essere introdotte nel contesto tramite la keyword ~intros~.

Siccome m e n sono numeri arbitrari non basta semplificare per dimostrare la nostra assunzione,  però possiamo provare a sostituire m con n e vedere se otteniamo due espressioni identiche da entrambi i lati.

Per fare "sostituzioni" utilizziamo la keyword ~rewrite~ con una freccia che indica da che lato va eseguita la sostituzione, ad esempio m -> n (sostituiamo la parte sinista con la parte desta) oppure m <- n il viceversa.

#+begin_src coq :session *coq* :session *coq*
  Theorem plus_id_example : forall n m : nat,
    n = m ->
    n + n = m + m.
    Proof.
      (* move both quantifiers into the context: *)
      intros n m.
      (* move the hypothesis into the context: *)
      intros H.
      (* rewrite the goal using the hypothesis: *)
      rewrite -> H.
      reflexivity. Qed.
#+end_src

In questa dimostrazione introduciamo n e m e l'ipotesi H per cui m = n, proviamo a sostituire n con la parte destra m e otteniamo (m + m) = (m + m) che è identica da entrambi i lati, per cui usiamo la strategia reflexivity.

Nota che -> non ha nulla a che fare con l'implicazione!

#+begin_src coq :session *coq* :session *coq*
  Theorem plus_id_example : forall n m : nat,
    n = m ->
    n + n = m + m.
  Proof.
    intros n m.
    intros H.
    (* Abbiamo invertito la freccia*)
    rewrite <- H.
    reflexivity. Qed.
#+end_src

Introduciamo la keywoard ~Admitted~ utilizzata negli esercizi, non fa altro che dire a Rocq che la dimostrazione è incompleta e la diamo per valida per ora per non fermare il flusso della valutazione del testo. Attenzione che potrebbe lasciare Rocq in uno stato insicuro. (I libro non elabora oltre)

La keyword ~Check~ può essere utilizzata per esaminare affermazioni di Lemma e Teoremi precedenemente dichiarati.

#+begin_src coq :session *coq*
Check mult_n_O.
(* ===> forall n : nat, 0 = n * 0 *)
Check mult_n_Sm.
(* ===> forall n m : nat, n * m + n = n * S m *)
#+end_src

Possiamo usare la ~rewrite~ per utilizzare teoremi precedentemente dimostrati all'interno della nostra dimostrazione al posto delle ipotesi, Rocq tenta di fare correttamente il matching con le variabili del nostro contesto.

#+begin_src coq :session *coq*
Theorem mult_n_0_m_0 : forall p q : nat,
  (p * 0) + (q * 0) = 0.
Proof.
  intros p q.
  rewrite <- mult_n_O.
  rewrite <- mult_n_O.
  reflexivity. Qed.
#+end_src

** Dimostrazioni tramite Analisi dei Casi

Per dimostrazioni più complicate le tattiche viste fin'ora non bastano, soprattutto quando abbiamo valori generali e ipotetici che possono bloccare la semplificazione.

#+begin_src coq :session *coq*

Theorem plus_1_neq_0_firsttry : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros n.
  simpl. (* does nothing! *)
Abort.
#+end_src

Abbiamo usato ~Abort~ per dire a Rocq che al momento ci arrendiamo al dimostrare questo teorema. Al contrario di ~Admitted~ ci impedisce di utilizzare questo teorema in successive dimostrazioni (non lo stiamo ammettendo).

Il motivo per cui la dimostrazione rimane bloccata è che sia eqb che + iniziano provando a fare matching sul primo argomento, ma il primo argomento di + è un valore sconosciuto e l'argomento di eqb è l'espressione composta n + 1.

Per poter continuare dobbiamo quindi chiederci quali sono le forme che può avere n, separatamente, per casi.
- Se n è 0 allora (n + 1) =? 0 non può essere vera
- Se n è un'espression S n' per qualche n' allora sapendo che *almeno* ha davanti un *S* è il successore di qualcosa, pur non sapendo che cosa questo "qualcosa" sia possiamo dire per certo che sommando 1 non otteniamo 0 e quindi l'affermazione è comunque falsa.

La tattica che si usa in Rocq per distinguere questi casi è ~destruct~.

#+begin_src coq :session *coq*
Theorem plus_1_neq_0 : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros n. destruct n as [| n'] eqn:E.
  - reflexivity.
  - reflexivity. Qed.
#+end_src

La tattica ~destruct~ ha generato in questo esempio due *casi*, o sotto-goal, per semplicità possiamo racchiudere questi sotto-goal con delle liste puntate, in modo tale da distringuere facilmente i due *scope* tramite una notazione a *bullet*. Ogni bullet è da dimostrare separatamente dall'altro per questo diciamo che sono *scopi* differenti.

Se non inseriamo la notazione a bullet Rocq si aspetta che dimostriamo ogni subgoal in sequenza uno alla volta, ma è buona norma inserirli per migliorare la leggibilità, soprattutto quando ogni sottogoal inizia a sua volta ad avere altri sottogoal.

La notazione `as [| n']` invece è chiamata =intro pattern=, dice a Rocq i nomi di variabile da introdurre per ogni sottogoal. In generale tra le parentesi quadre viene inserita una /lista di liste/ di nomi, separati da |. In questo caso il primo componente è vuoto *siccome il costruttore O non prende argomenti*, mentre siccome *S* è un operatore unario diamo come nome del suo argomento n'.

In ogni sottogoal Rocq si ricorda l'assunzione riguardante n inerente a quel sottogoal, ovvero il fatto che o n = O oppure n = S n' per qualche n'. l'annotazione eqn:E dice alla destruct di dare il nome E a questa equazione.

*ATTENZIONE*: Se viene omesso eqn:E Rocq ignora questa assunzione nei sottogoal, mentre questo può essere utile in alcuni casi (ad esempio in dimostrazioni in cui queste assunzioni non sono utili) è sempre buona pratica metterlo.
 
La tattica ~destruct~ può essere utilizzata con ogni tipo di dato definito induttivamente. Nell'esempio viene dimostrata l'involuzione della negazione. (la negazione è la sua inversa)

#+begin_src  coq :session *coq*
 Theorem negb_involutive : forall b : bool,
  negb (negb b) = b.
Proof.
  intros b. destruct b eqn:E.
  - reflexivity.
  - reflexivity. Qed.
#+end_src

Notare che siccome nessun sottocaso ha bisogno di associare variabili non vengono specificati nomi. Inoltre, se non specifichiamo i nomi in qualunque destruct Rocq si occuperà di inventarseli, generalmente è da evitare.

Un esempio in cui abbiamo subgoal che a loro volta generano subgoal

#+begin_src coq :session *coq*
Theorem andb_commutative : forall b c, andb b c = andb c b.
Proof.
  intros b c. destruct b eqn:Eb.
  - destruct c eqn:Ec.
    + reflexivity.
    + reflexivity.
  - destruct c eqn:Ec.
    + reflexivity.
    + reflexivity.
Qed.
#+end_src

Come *bullet* si possono usare -, + e ogni sequenza di asterischi \*\*\*. Oppure in alternativa delle parentesi graffe.
Ed è possibile combinarli insieme in base alla preferenza.

#+begin_src coq :session *coq*
Theorem andb_commutative' : forall b c, andb b c = andb c b.
Proof.
  intros b c. destruct b eqn:Eb.
  { destruct c eqn:Ec.
    { reflexivity. }
    { reflexivity. } }
  { destruct c eqn:Ec.
    { reflexivity. }
    { reflexivity. } }
Qed.

Theorem andb3_exchange :
  forall b c d, andb (andb b c) d = andb (andb b d) c.
Proof.
  intros b c d. destruct b eqn:Eb.
  - destruct c eqn:Ec.
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
  - destruct c eqn:Ec.
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
Qed.
#+end_src

Un'ultima nota che aggiunge il libro, siccome spesso le dimostrazioni fanno analisi per casi su variabili appena introdotte, Rocq aggiunge una comodità.

Invece di 

#+begin_src  coq
intros x y. destruct y as [|y] eqn:E.
#+end_src

Possiamo introdurre il pattern direttamente in ~intros~

#+begin_src coq :session *coq*
Theorem plus_1_neq_0' : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros [|n].
  - reflexivity.
  - reflexivity. Qed.
#+end_src

E se non ci sono costruttori possiamo direttamente usare [] per iniziare l'analisi per casi direttamente.

#+begin_src coq :session *coq*
Theorem andb_commutative'' :
  forall b c, andb b c = andb c b.
Proof.
  intros [] [].
  - reflexivity.
  - reflexivity.
  - reflexivity.
  - reflexivity.
Qed.
#+end_src

Alcune note veloci sui sottocapitoli "opzionali"

#+begin_src coq :session *coq*
 Notation "x + y" := (plus x y)
                       (at level 50, left associativity)
                       : nat_scope.
Notation "x * y" := (mult x y)
                       (at level 40, left associativity)
                       : nat_scope.
#+end_src

Qui level indica il livello di precedenza dell'operatore per disambiguare casi come 1+2*3*4 e dare precedenza agli operatori. Alcuni valori che può usare sono da 0 a 100, left, right, o no associativity.
Invece nat_scope serve ad aiutare Rocq a capire lo scopo dell'operatore dal contesto, quando vede S (O * O) capisce che è nat_scope mentre se dovesse vedere una coppia bool*bool allora indovinerebbe type_scope. Spesso il contesto della notazione è ambiguo e va aiutato come nel caso (x×y)%nat.

#+begin_src coq :session *coq*
  Fixpoint plus' (n : nat) (m : nat) : nat :=
    match n with
    | O => m
    | S n' => S (plus' n' m)
    end.
#+end_src

In questa notazione della somma Rocq si rende conto che plus` "decresce sul primo argomento" questo significa che sta eseguendo una "ricorsione strutturale" sull'argomento n. Ovvero esegue chiamate di funzione solo su valori strettamente più piccoli di n, in questo modo si assicura che la funzione ricorsiva eventualmente termina (in Rocq è garantito che ogni funzione termina). Ogni definizione ~Fixpoint~ in Rocq deve essere /decrescente/ in questa maniera. Il problema è che l'analisi che fa Rocq per comprendere se queste funzioni sono decrescenti non è molto sofisticata spesso bisogna riscrivere le funzioni in maniera poco intuitiva.

* Induzione

#+begin_src coq :session *coq*
From LF Require Export Basics.
#+end_src

Una dimostrazione semplice per la somma tra numeri naturali è la somma per zero, nel caso consideriamo lo zero a sinistra è banale per la costruzione stessa della somma, sul lato destro invece le cose si complicano.

#+begin_src coq :session *coq*
Theorem add_0_r_firsttry : forall n:nat,
  n + 0 = n.
Proof.
  intros n.
  simpl. (* Does nothing! *)
Abort.
#+end_src

Potremmo provare ad usare ~destruct~ per provare a ragionare per casi su n ma non andiamo molto lontano, possiamo vedere che vale per ~n = 0~ senza difficoltà ma poi rimaniamo bloccati a ~n = S n'~ per qualche n' siccome non è possibile semplificare questa espressione utilizzando il matching della somma. Esattamente nello stesso modo di prima.

#+begin_src coq :session *coq*
Theorem add_0_r_secondtry : forall n:nat,
  n + 0 = n.
Proof.
  intros n. destruct n as [| n'] eqn:E.
  - (* n = 0 *)
    reflexivity. (* so far so good... *)
  - (* n = S n' *)
    simpl. (* ...but here we are stuck again *)
Abort.
#+end_src
 
Potremmo provare ~destruct n'~ per andare un pelo oltre, ma siccome n è arbitrariamente grande, potremmo non raggiungere mai una conclusione. Per dimostrare fatti su numeri naturali, liste e altri insiemi definiti ricorsivamente abbiamo bisogno del meccanismo dell' =induzione=.

Ricordiamo il /principio di induzione sui numeri naturali/
Per dimostrare che una proposizione =P(n)= vale per tutti i numeri naturali allora bisogna:
- Mostrare che ~P(0)~ vale.
- Mostrare che per ogni ~n'~ naturale, se ~P(n')~ vale allora che ~P(S n')~ vale.
- Concludiamo quindi che ~P(n)~ vale per qualunque ~n~ naturale.

In Rocq gli step sono uguali, solo che in genere gli incontriamo in ordine opposto. Iniziamo con l'obiettivo di provare ~P(n)~ per ogni n, applichiamo la tattica ~induction~ per rompere il goal in sottogoal (che sono gli step dell'induzione).

#+begin_src coq *coq*
Theorem add_0_r : forall n:nat, n + 0 = n.
Proof.
  intros n. induction n as [| n' IHn'].
  - (* n = 0 *) reflexivity.
  - (* n = S n' *) simpl. rewrite → IHn'. reflexivity. Qed.
#+end_src

Notiamo come ~destruct~ anche induction  usa le clausole dopo ~as~ questo serve a dare un nome alle variabili introdotte nei sottogoal. Usiamo una barra | perchè abbiamo due sottogoal, nel primo non ci interessa introdurre nuove variabili quindi rimane vuoto, mentre nel secondo introduciamo ~n'~ e l'*ipotesi induttiva stessa* ~IHn'~ che sta per "Inductive Hypothesis over n'". È sempre consigliato dare questi nomi siccome altrimenti Rocq prova a inventarseli e posso risultare confusionari.

Nel primo sottogoal ~n~ è sostituito con ~0~, viene dimostrata la validità semplicemente con ~reflexivity~.
Nel secondo sottogoal ~n~ è rimpiazzato da ~S n'~ e l'assunzione ~n' + 0 = n'~ è aggiunta al contesto con il nome ~IHn'~. Il goal diventa =S n' == (S n') + 0= che si semplifica a =S n' = S (n' + 0)=,  riscrivendo l'ipotesi =IHn'= otteniamo quindi un'identità, dimostrando il sottogoal.

#+begin_src coq :session *coq*
 Theorem minus_n_n : forall n,
  minus n n = 0.
Proof.
  intros n. induction n as [| n' IHn'].
  - (* n = 0 *)
    simpl. reflexivity.
  - (* n = S n' *)
    simpl. rewrite → IHn'. reflexivity. Qed.
#+end_src

Notiamo che l'uso di ~intros n~ in queste dimostrazioni è ridondante in quanto ~induction~ si occupa di introdurre nel nostro contesto tutte le variabili necessarie per il goal corrente.

** Dimostrazioni all'interno di dimostrazioni

In Rocq come nelle definizioni informali, grandi dimostrazioni possono essere spezzettate in dimostrazioni più piccole intermedie che vengono poi riutilizzate per dimostrare il teorema più grosso. Spesso però queste asserzioni sono fatti semplici e banali oppure troppo generali che non si "meritano" un nome, in questi casi si può usare questo "fatto" necessario "in-place", per fare questo in Rocq usiamo la keyword ~replace~. (da non confondere con ~rewrite~)

#+begin_src coq :session *coq*
Theorem mult_0_plus' : forall n m : nat,
  (n + 0 + 0) × m = n × m.
Proof.
  intros n m.
  replace (n + 0 + 0) with n.
  - reflexivity.
  - rewrite add_comm. simpl. rewrite add_comm. reflexivity.
Qed.

#+end_src

La tattica ~replace~ e1 with e2 genera due sottogoal, quello su cui invochiamo la ~replace~ con come differenza il fatto che =e1=  è ripiazzato da =e2= ed il sottogoal dell'uguaglianza stessa ~e1 = e2~.

Come altro esempio possiamo provare ~(n + m) + (p + q) = (m + n) + (p + q)~, l'unica differenza tra le due parti  dell'uguaglianza ~=~ è che gli argomenti ~m~ ed ~n~ della prima addizione interna sono invertiti. In questo caso potremmo usare la commutatività dell'addizione tramite la ~rewrite add_com~, ma siccome ~rewrite~ in Rocq non è molto intelligente sul *dove* va applicata essa altera solo la somma /esterna/

#+begin_src coq :session *coq*
Theorem plus_rearrange_firsttry : forall n m p q : nat,
  (n + m) + (p + q) = (m + n) + (p + q).
Proof.
  intros n m p q.
  (* We just need to swap (n + m) for (m + n)... seems
    like add_comm should do the trick! *)
  rewrite add_comm.
  (* Doesn't work... Rocq rewrites the wrong plus! :-( *)
Abort.
#+end_src

Per usare ~add_comm~ esattamente dove vogliamo in questo caso torna utile il comando ~replace~ e poi *dimostrando il sottogoal generato* utilizzando ~rewrite add_comm~.

#+begin_src coq :session *coq*
Theorem plus_rearrange : forall n m p q : nat,
  (n + m) + (p + q) = (m + n) + (p + q).
Proof.
  intros n m p q.
  replace (n + m) with (m + n).
  - reflexivity.
  - rewrite add_comm. reflexivity.
Qed.
#+end_src

** Dimostrazioni Formali vs Dimostrazioni Informali

/Le dimostrazioni informali sono algoritmi; le dimostrazioni formali sono codice./

Le dimostrazioni formali in Rocq sono precise ma difficili da capire per gli umani.
Una dimostrazione informale scritta da un matematico comunica meglio le idee: spiega esplicitamente lo stato della dimostrazione ad ogni passo ("dobbiamo mostrare che...", "supponiamo che...") mentre la versione formale rende implicito il contesto e usa tattiche (come ~reflexivity~) che /nascondono i passaggi logici/. 
Entrambe seguono la stessa struttura (induzione su n, caso base, caso induttivo) ma bilanciano diversamente esplicitezza e dettaglio.

Non possiamo ignorare le dimostrazioni informali.

Per Rocq questa è una dimostrazione valida, ma per un umano è difficile a prima vista da comprendere.
#+begin_src coq :session *coq*
Theorem add_assoc' : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof. intros n m p. induction n as [| n' IHn']. reflexivity.
  simpl. rewrite IHn'. reflexivity. Qed.
#+end_src

Possiamo aiutarci con dei commenti. Ma comunque se fosse un minimo più complicata sarebbe semplice perdere il filo del discorso.
#+begin_src coq :session *coq*
 Theorem add_assoc'' : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof.
  intros n m p. induction n as [| n' IHn'].
  - (* n = 0 *)
    reflexivity.
  - (* n = S n' *)
    simpl. rewrite IHn'. reflexivity. Qed.
#+end_src

Un matematico pignolo scriverebbe la dimostrazione in questo modo

#+begin_quote
Teorema: Per ogni n, m e p,
          n + (m + p) = (n + m) + p.

Dimostrazione. Per induzione su n.
- Prima, supponiamo n = 0, dobbiamo mostrare che:
                0 + (m + p) = (0 + m) + p.
        Questo deriva direttamente dalla definizione di +.

- Successivamente, supponiamo n = S n' , dove
                n' + (m + p) = (n' + m) + p.
        Dobbiamo mostrare che
                (S n') + (m + p) = ((S n') + m) + p.
        Per definizione di +, questo deriva da
                S (n' + (m + p)) = S ((n' + m) + p),
       che è immediato dall'ipotesi di induzione. Qed.
#+end_quote

La struttura generale è simile perché Rocq genera gli stessi sottoobiettivi nell'ordine degli elenchi puntati matematici. Tuttavia ci sono differenze nei dettagli: Rocq è più esplicito nell'uso di tattiche specifiche come ~reflexivity~, ma meno esplicito riguardo lo stato della dimostrazione che rimane implicito. Al contrario, la dimostrazione informale /ricorda esplicitamente al lettore dove si trova ad ogni passo/.

* Liste

#+begin_src coq :session *coq*
From LF Require Export Induction.
Module NatList.
#+end_src

Nel definire tipi induttivamente ogni costruttore può prendere un numero diverso di argomenti, nessuno (come 0 o true), uno (come S) o di più (come nibble e quello di seguito)

#+begin_src coq :session *coq*
Inductive natprod : Type :=
  | pair (n1 n2 : nat).
#+end_src

Che si può leggere come "L'unico modo per costruire una coppia di numeri naturali è applicando ~pair~ a due argomenti di tipo nat.

#+begin_src coq :session *coq*
Check (pair 3 5) : natprod.
#+end_src

Tramite pattern matching possiamo definire funzioni che estraggono il primo o il secondo elemento

#+begin_src coq :session *coq*
Definition fst (p : natprod) : nat :=
  match p with
  | pair x y => x
  end.

Definition snd (p : natprod) : nat :=
  match p with
  | pair x y => y
  end.
Compute (fst (pair 3 5)).
  (* ===> 3 *)
#+end_src

Siccome useremo spesso questo tipo di ~pair~ conviene definire una notazione più comoda.

#+begin_src coq :session *coq*
Notation "( x , y )" := (pair x y).
#+end_src

Questa notazione si può usare *sia nelle espressioni che nel pattern matching*:
#+begin_src coq :session *coq*
Compute (fst (3,5)).

Definition fst' (p : natprod) : nat :=
  match p with
  | (x,y) => x
  end.

Definition snd' (p : natprod) : nat :=
  match p with
  | (x,y) => y
  end.

Definition swap_pair (p : natprod) : natprod :=
  match p with
  | (x,y) => (y,x)
  end.
#+end_src

Una nota che indica il libro è di non confondere questa notazione con la sintassi senza parentesi dei pattern multipli come ad esempio.

#+begin_src coq :session *coq*
Fixpoint minus (n m : nat) : nat :=
  match n, m with
  | O   , _    => O
  | S _ , O    => n
  | S n', S m' => minus n' m'
  end.
#+end_src

La distinzione è minima ma da notare, in questi esempi errato viene presentata meglio.

#+begin_src coq :session *coq*
(* Can't match on a pair with multiple patterns: *)
Definition bad_fst (p : natprod) : nat :=
  match p with
  | x, y => x
  end.

(* Can't match on multiple values with pair patterns: *)
Definition bad_minus (n m : nat) : nat :=
  match n, m with
  | (O   , _   ) => O
  | (S _ , O   ) => n
  | (S n', S m') => bad_minus n' m'
  end.
#+end_src

 If we state properties of pairs in a slightly peculiar way, we can sometimes complete their proofs with just reflexivity and its built-in simplification:

 Spesso possiamo completare le dimostrazioni sulle coppie usando solo la riflessività e le semplificazioni automatiche. Ma se scriviamo il lemma in maniera più naturale la semplificazione non basta.
 
#+begin_src coq :session *coq*
Theorem surjective_pairing' : forall (n m : nat),
  (n,m) = (fst (n,m), snd (n,m)).
Proof.
  reflexivity. Qed.

Theorem surjective_pairing_stuck : forall (p : natprod),
  p = (fst p, snd p).
Proof.
  simpl. (* Doesn't reduce anything! *)
Abort.
#+end_src

Esponendo la struttura di ~p~ allora ~simpl~ può fare pattern matching  in ~fst~ e ~snd~. Per fare questo usiamo una ~destruct~.

#+begin_src coq :session *coq*
Theorem surjective_pairing : forall (p : natprod),
  p = (fst p, snd p).
Proof.
  intros p. destruct p as [n m]. simpl. reflexivity. Qed.
#+end_src

** Liste di numeri

Possiamo definire una /lista/ di /numeri/ come:
- Una lista vuota
- Una coppia tra un /numero naturale/ e una /lista/.
Per chi conosce Lisp/Scheme questo pattern risulta molto famigliare.

 #+begin_src coq :session *coq*
Inductive natlist : Type :=
  | nil
  | cons (n : nat) (l : natlist).
 #+end_src

 Un esempio di utilizzo:

 #+begin_src coq :session *coq*
Definition mylist := cons 1 (cons 2 (cons 3 nil)).
 #+end_src

 Come nel caso precedente Rocq definisce una notazione comoda. Specificando l'*associatività a destra* per l'appendere un valore a una lista e una notazione comoda per le liste n-arie con le parentesi quadre.

 #+begin_src coq :session *coq*
Notation "x :: l" := (cons x l)
                     (at level 60, right associativity).
Notation "[ ]" := nil.
Notation "[ x ; .. ; y ]" := (cons x .. (cons y nil) ..).
 #+end_src

 Tutte queste definizioni di esempio sono equivalenti. Con le parentesi è possibile vedere esplicitamente come funziona l'associatività a destra, ogni valore è accoppiato con il valore o l'espressione a destra.

 #+begin_src coq :session *coq*
Definition mylist1 := 1 :: (2 :: (3 :: nil)).
Definition mylist2 := 1 :: 2 :: 3 :: nil.
Definition mylist3 := [1 ; 2 ; 3].
 #+end_src

Nella notazione ~"x + y" := (plus x y) (at level 50, left associativity)~.
L'operatore + sarà più *strettamente vincolato* di ~::~, quindi ~1 + 2 :: [3]~ verrà analizzato, come ci si aspetterebbe, come ~(1 + 2) :: [3]~ anziché ~1 + (2 :: [3])~.

** Alcune Funzioni per manipolare liste

La funzione ~repeat~ ritorna una lista di lunghezza count in cui ogni elemento è ~n~.

#+begin_src coq :session *coq*
Fixpoint repeat (n count : nat) : natlist :=
  match count with
  | O => nil
  | S count' => n :: (repeat n count')
  end.
#+end_src

La funzione  ~length~ calcola la lunghezza di una lista l

#+begin_src coq :session *coq*
Fixpoint length (l : natlist) : nat :=
  match l with
  | nil => O
  | h :: t => S (length t)
  end.
#+end_src

La funzione ~app~ (append) concatena tra loro due liste

#+begin_src coq :session *coq*
 Fixpoint app (l1 l2 : natlist) : natlist :=
  match l1 with
  | nil => l2
  | h :: t => h :: (app t l2)
  end.
#+end_src

Siccome è un operatore molto utilizzato è definita una notazione anche per ~app~ tramite ~++~. 

#+begin_src coq :session *coq*
 Notation "x ++ y" := (app x y) (right associativity, at level 60).

Example test_app1: [1;2;3] ++ [4;5] = [1;2;3;4;5].
  Proof. reflexivity. Qed.

Example test_app2: nil ++ [4;5] = [4;5].
  Proof. reflexivity. Qed.

Example test_app3: [1;2;3] ++ nil = [1;2;3].
  Proof. reflexivity. Qed.
#+end_src

Altre due funzioni utili sono ~hd~ e ~tl~ (*head* e *tail*) che ritornarno rispettivamente il primo elemento di una lista ed i restanti elementi (come in common lisp) siccome la lista vuota non ha elementi dobbiamo chiedere all'utente un elemento di =default= da ritornare in quel caso, questo perchè tutte le funzioni in Rocq devono essere totali.

#+begin_src coq :session *coq*
Definition hd (default : nat) (l : natlist) : nat :=
  match l with
  | nil ⇒ default
  | h :: t ⇒ h
  end.

Definition tl (l : natlist) : natlist :=
  match l with
  | nil ⇒ nil
  | h :: t ⇒ t
  end.

Example test_hd1: hd 0 [1;2;3] = 1.
  Proof. reflexivity. Qed.
Example test_hd2: hd 0 [] = 0.
  Proof. reflexivity. Qed.
Example test_tl: tl [1;2;3] = [2;3].
  Proof. reflexivity. Qed.
#+end_src

** Reasoning su liste

Spesso per provare fatti su funzioni che manipolano liste bastano ~simpl~ e ~reflexivity~ come ad esempio in:

#+begin_src coq :session *coq*
Theorem nil_app : forall l : natlist,
  [] ++ l = l.
Proof. reflexivity. Qed.
#+end_src

Siccome ~[]~ viene direttamente ridotta nel matching della definizione di ~app~.

Come con i numeri naturali spesso è utile fare analisi per casi su le forme che possono avere le liste vuote o non vuote come in

#+begin_src coq :session *coq*
Theorem tl_length_pred : forall l:natlist,
  pred (length l) = length (tl l).
Proof.
  intros l. destruct l as [| n l'].
  - (* l = nil *)
    reflexivity.
  - (* l = cons n l' *)
    reflexivity. Qed.
#+end_src

Qui, il caso nil funziona perché abbiamo scelto di definire tl nil = nil. Notiamo che l'annotazione ~as~ sulla tattica di ~destruct~ introduce due nomi , =n= e =l'= corrispondenti al fatto che il costruttore ~cons~ per le liste accetta due argomenti (la testa e la coda della lista che sta costruendo).
Di solito, però, i teoremi interessanti sulle liste richiedono l'induzione per la loro dimostrazione. 

** Induzione su liste

L'induzione sui tipi di dati (come le liste) segue lo stesso principio dell'induzione sui numeri naturali. Poiché ogni insieme definito induttivamente è composto esclusivamente dai suoi costruttori (ad esempio, una lista può essere solo ~nil~ o il risultato di un ~cons~), per dimostrare che una proprietà =P= valga per tutti gli elementi è sufficiente:

1.  **Caso base**: Dimostrare che =P= è vera per il costruttore più semplice (es. la lista vuota ~nil~).
2.  **Passo induttivo**: Dimostrare che =P= è vera per una struttura composta (es. ~cons n l'~), assumendo come ipotesi che la proprietà sia già valida per la sottostruttura più piccola (=l'=).

Poiché ogni elemento complesso può essere scomposto fino a raggiungere il caso base, questi due passaggi garantiscono che la proprietà sia valida per l'intero insieme.

Vediamo un esempio

#+begin_src coq :session *coq*
Theorem app_assoc : forall l1 l2 l3 : natlist,
  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).
Proof.
  intros l1 l2 l3. induction l1 as [| n l1' IHl1'].
  - (* l1 = nil *)
    reflexivity.
  - (* l1 = cons n l1' *)
    simpl. rewrite → IHl1'. reflexivity. Qed.
#+end_src

Notiamo che come con i numeri naturali la clausola di ~as~ della tattica ~induction~ da un nome all'ipotesi di induzione corrispondente alla lista più piccola ~l1'~ del caso della =cons=.

Il libro riporta una dimostrazione informale per colmare la difficoltà di leggere Rocq come documento statico invece che come dimostratore interattivo (queste note colmano comunque questa difficoltà).

#+begin_example coq

Teorema: Per ogni lista l1, l2, e l3, (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3)

Dimostrazione: Per induzione su l1.

- Prima, supponiamo l1 = []. Dobbiamo mostrare che:

                 ([] ++ l2) ++ l3 = [] ++ (l2 ++ l3)

  il che segue direttamente dalla definizione di ++.

- Poi, supponiamo l1 = n::l1' con

                (l1' ++ l2) ++ l3 = l1' ++ (l2 ++ l3)  
  
  (l'ipotesi induttiva) Dobbiamo mostrare che
  
                ((n :: l1') ++ l2) ++ l3 = (n :: l1') ++ (l2 ++ l3)

  Per la definizione di ++, ne consegue che

                n :: ((l1' ++ l2) ++ l3) = n :: (l1' ++ (l2 ++ l3))

che è immediato dall'ipotesi induttiva. ☐
#+end_example

** Assunzioni da Generalizzare

Spesso in una dimostrazione è necessario generalizzare uno statement per completare una dimostrazione per induzione. L'intuizione è che un'assunzione più generale può portare ad un'ipotesi induttiva più forte. Se ci si sente bloccati in una dimostrazione potrebbe rivelarsi utile fare un passo indietro e vedere se si può dimostrare un'assuzione più forte. 

Consiglio di eseguire questo snippet con proof-general per capirne meglio il motivo.

#+begin_src coq :session *coq*
  Theorem repeat_double_firsttry : forall c n: nat,
    repeat n c ++ repeat n c = repeat n (c + c).
  Proof.
    intros c. induction c as [| c' IHc'].
    - (* c = 0 *)
      intros n. simpl. reflexivity.
    - (* c = S c' *)
      intros n. simpl.
      (*  Now we seem to be stuck.  The IH cannot be used to
          rewrite repeat n (c' + S c'): it only works
          for repeat n (c' + c'). If the IH were more liberal here
          (e.g., if it worked for an arbitrary second summand),
          the proof would go through. *)
  Abort.
#+end_src

Possiamo sbloccarci generalizzando l'assunzione come segue 

#+begin_src coq :session *coq*
Theorem repeat_plus: forall c1 c2 n: nat,
    repeat n c1 ++ repeat n c2 = repeat n (c1 + c2).
Proof.
  intros c1 c2 n.
  induction c1 as [| c1' IHc1'].
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHc1'.
    reflexivity.
  Qed.
#+end_src


